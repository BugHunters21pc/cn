#reciever Go back N arq

import socket

# Initialize socket
sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
server_address = ('localhost', 10000)
sock.bind(server_address)

# Expected sequence number
expected_seq_num = 0

# Window size
N = 3

while True:
    # Receive packet
    packet, address = sock.recvfrom(1024)
    packet_data = packet.decode().split(':')
    seq_num = int(packet_data[0])
    message = packet_data[1]
    
    print("OUTER")
    # Check sequence number
    if seq_num == expected_seq_num:
        print(message)

        # Send ACK
        ack = str(seq_num)
        sock.sendto(ack.encode(), address)

        # Move window
        expected_seq_num += 1
        print("exp_seq :", expected_seq_num)

        # Handle out-of-order packets
        while True:
            print("INNER")
            try:
                packet, address = sock.recvfrom(1024)
                packet_data = packet.decode().split(':')
                seq_num = int(packet_data[0])
                message = packet_data[1]

                if seq_num == expected_seq_num:
                    print(message)

                    # Send ACK
                    ack = str(seq_num)
                    sock.sendto(ack.encode(), address)

                    # Move window
                    expected_seq_num += 1
                else:
                    break
            except socket.timeout:
                break
    else:
        # Discard packet
        pass

#sender Go Back N arq

import socket

# Initialize socket
sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
server_address = ('localhost', 10000)

# Data to be sent
data = ['packet1', 'packet2', 'packet3', 'packet4', 'packet5']

# Window size
N = 3

# Sequence number
seq_num = 0

# Send packets
while seq_num < len(data):
    print(f"seq:{seq_num}")
    # Send N packets
    for i in range(seq_num, min(seq_num + N, len(data))):
        message = str(seq_num) + ':' + data[i]
        print(message)
        sock.sendto(message.encode(), server_address)
    # Wait for ACKs
    try:
        sock.settimeout(1)
        while True:
            ack, address = sock.recvfrom(1024)
            ack_seq_num = int(ack.decode())
            print(f"ack: {ack_seq_num}")
            if ack_seq_num >= seq_num:
                seq_num = ack_seq_num + 1
                
    except socket.timeout:
        pass

#Dijikstra

import heapq

def dijkstra(graph, start):
    distances = {vertex: float('infinity') for vertex in graph}  # Set all initial distances to infinity
    #print(distances)
    distances[start] = 0  # Set the starting vertex's distance to 0
    pq = [(0, start)]  # Add the starting vertex to the heap with priority 0
   
    visited = set()  # Keep track of visited vertices
    
    while pq:
        current_distance, current_vertex = heapq.heappop(pq)  # Get the vertex with the smallest distance
        
        print (current_distance, current_vertex)
        #print(pq)
        if current_vertex in visited:
            continue  # Skip if we've already visited this vertex
        
        visited.add(current_vertex)  # Mark the vertex as visited
        
        for neighbor, weight in graph[current_vertex].items():  # Check each neighboring vertex
            distance = current_distance + weight  # Calculate the distance to the neighboring vertex
            
            if distance < distances[neighbor]:  # If the new distance is less than the previously calculated distance
                distances[neighbor] = distance  # Update the distance
                heapq.heappush(pq, (distance, neighbor))  # Add the neighboring vertex to the heap with the updated distance
        #print(distances)       
    return distances


graph = {
    'A': {'B': 3, 'C': 4, 'D': 2},
    'B': {'A': 3, 'C': 5, 'E': 9},
    'C': {'A': 4, 'B': 5, 'D': 1, 'E': 6},
    'D': {'A': 2, 'C': 1, 'F': 8},
    'E': {'B': 9, 'C': 6, 'F': 7},
    'F': {'D': 8, 'E': 7}
}

start_vertex = 'A'
distances = dijkstra(graph, start_vertex)
print(distances)

#Dijkstra if src and dst

import heapq


def dijkstra(graph, start, end):
    distances = {vertex: float('infinity') for vertex in graph}  # Set all initial distances to infinity
    distances[start] = 0  # Set the starting vertex's distance to 0
    pq = [(0, start)]  # Add the starting vertex to the heap with priority 0
    visited = set()  # Keep track of visited vertices
    previous_vertices = {vertex: None for vertex in graph}  # Keep track of previous vertices
    
    while pq:
        current_distance, current_vertex = heapq.heappop(pq)  # Get the vertex with the smallest distance
        
        if current_vertex == end:
            break  # If we've reached the end vertex, exit the loop
        
        if current_vertex in visited:
            continue  # Skip if we've already visited this vertex
        
        visited.add(current_vertex)  # Mark the vertex as visited
        
        for neighbor, weight in graph[current_vertex].items():  # Check each neighboring vertex
            distance = current_distance + weight  # Calculate the distance to the neighboring vertex
            
            if distance < distances[neighbor]:  # If the new distance is less than the previously calculated distance
                distances[neighbor] = distance  # Update the distance
                previous_vertices[neighbor] = current_vertex  # Update the previous vertex
                heapq.heappush(pq, (distance, neighbor))  # Add the neighboring vertex to the heap with the updated distance
                
    path = [end]  # Start with the end vertex
    current_vertex = end
    
    while current_vertex != start:
        previous_vertex = previous_vertices[current_vertex]
        path.append(previous_vertex)
        current_vertex = previous_vertex
        
    path.reverse()  # Reverse the path to get the correct order
    
    return distances[end], path


graph = {
    'R1': {'R2': 10, 'R3': 5, 'NetworkA': 0, 'NetworkB': 0},
    'R2': {'R1': 10, 'R3': 6, 'NetworkC': 0},
    'R3': {'R1': 5, 'R2': 6, 'NetworkD': 0},
    'NetworkA': {'R1': 0},
    'NetworkB': {'R1': 0},
    'NetworkC': {'R2': 0},
    'NetworkD': {'R3': 0}
}


start_vertex = 'NetworkA'
end = 'NetworkD'
distance, path = dijkstra(graph, start_vertex, end)
print(f"The shortest distance from {start_vertex} to {end} is {distance}.")
print(f"The path is {path}.")


#Bellman ford

def bellman_ford(graph, start):
    # Initialize the distances dictionary with start vertex having distance 0 and all other vertices having infinity distance.
    distances = {vertex: float('infinity') for vertex in graph}
    distances[start] = 0
    
    # Iterate over all edges V-1 times, where V is the number of vertices in the graph.
    for _ in range(len(graph) - 1):
        # For each edge (u, v) with weight w in the graph, update the distance to v if the distance to u plus w is smaller than the current distance to v.
        for u in graph:
            for v, w in graph[u].items():
                if distances[u] + w < distances[v]:
                    distances[v] = distances[u] + w
    
    # Check for negative-weight cycles.
    for u in graph:
        for v, w in graph[u].items():
            if distances[u] + w < distances[v]:
                raise ValueError("Negative weight cycle detected")
    
    return distances

graph = {
    'A': {'B': 3, 'C': 4, 'D': 2},
    'B': {'A': 3, 'C': 5, 'E': 9},
    'C': {'A': 4, 'B': 5, 'D': 1, 'E': 6},
    'D': {'A': 2, 'C': 1, 'F': 8},
    'E': {'B': 9, 'C': 6, 'F': 7},
    'F': {'D': 8, 'E': 7}
}

print(bellman_ford(graph, 'A'))

#ip fragmentation

import sys

def ip_fragmentation(data, mtu):
    # Maximum IP packet size is 65535 bytes
    max_size = 65535
    
    # Calculate the number of fragments needed
    num_fragments = (len(data) // (mtu - 20)) + 1 if len(data) % (mtu - 20) != 0 else (len(data) // (mtu - 20))
    
    # Create an empty list to store the fragments
    fragments = []
    
    # Generate a unique identifier for the IP packet
    ip_id = 1234
    
    # Create the IP header
    ip_header = b'\x45\x00\x00\x00'  # Version, header length, type of service
    ip_header += (max_size).to_bytes(2, byteorder='big')  # Total length
    ip_header += (ip_id).to_bytes(2, byteorder='big')  # Identification
    ip_header += b'\x00\x00\x00\x00'  # Flags, fragment offset
    ip_header += b'\x40\x00\x00\x00'  # Time-to-live, protocol
    ip_header += b'\x00\x00'  # Header checksum
    ip_header += b'\x00\x00\x00\x00'  # Source IP address
    ip_header += b'\x00\x00\x00\x00'  # Destination IP address
    
    # Loop through the data and fragment it
    for i in range(num_fragments):
        # Calculate the offset for this fragment
        offset = (i * (mtu - 20)) // 8
        
        # Create the IP header for this fragment
        fragment_header = ip_header[:6]  # Version, header length, type of service
        fragment_header += (mtu).to_bytes(2, byteorder='big')  # Total length
        fragment_header += (ip_id).to_bytes(2, byteorder='big')  # Identification
        fragment_header += (((i != num_fragments - 1) * 2**13) + offset).to_bytes(2, byteorder='big')  # Flags, fragment offset
        fragment_header += ip_header[10:]  # Time-to-live, protocol, header checksum, source and destination IP addresses
        
        # Create the fragment by appending the header and the data
        fragment = fragment_header + data[i * (mtu - 20):(i + 1) * (mtu - 20)]
        
        # Add the fragment to the list of fragments
        fragments.append(fragment)
    
    # Return the list of fragments
    return fragments

def ip_reassembly(fragments):
    # Create a dictionary to store the fragments
    fragment_dict = {}
    
    # Loop through the fragments and store them in the dictionary
    for fragment in fragments:
        # Extract the identification and flags/offset fields from the IP header
        ip_id = int.from_bytes(fragment[4:6], byteorder='big')
        flags_offset = int.from_bytes(fragment[6:8], byteorder='big')
        
        # Extract the flags and fragment offset from the flags/offset field
        flags = flags_offset & 0xE000
        offset = flags_offset & 0x1FFF
        
        # If this is the first fragment, create a new entry in the dictionary
        if flags == 0:
            fragment_dict[ip_id] = [None] * ((offset + len(fragment) - 20) // 8 + 1)
        
        # Add the fragment to the list in the dictionary at the appropriate offset
        fragment_dict[ip_id][offset // 8] = fragment[20:]
    
    # Combine the fragments into a single bytearray
    datagram = bytearray()
    for key, value in fragment_dict.items():
        for fragment in value:
            if fragment is not None:
                datagram += fragment
    
    # Extract the original message from the datagram
    message = datagram[20:]
    
    # Return the datagram and the message
    return datagram, message


# Fragment the message
message = b'This is a test message to be fragmented into multiple IP packets.'
mtu = 50
fragments = ip_fragmentation(message, mtu)

print(fragments)

# Reassemble the fragments
datagram, message = ip_reassembly(fragments);          

# Print the results
print('Datagram:', datagram.hex())
print('Message:', message.decode())

#sender part for ip

import socket
import sys
sys.path.append('/path/to/the/directory')

# Define the address and port to send the message to
address = '127.0.0.1'
port = 12345

# Define the message to send
message = b'This is a test message to be fragmented into multiple IP packets.'

# Define the maximum transmission unit (MTU) for the network
mtu = 50

# Fragment the message
fragments = ip_fragmentation(message, mtu)

# Create a UDP socket
sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)

# Send each fragment over the network
for fragment in fragments:
    sock.sendto(fragment, (address, port))

# Close the socket
sock.close()

#reciever part for ip

import socket
import sys
sys.path.append('/path/to/the/directory')

# Define the address and port to receive the message on
address = '127.0.0.1'
port = 12345

# Create a UDP socket
sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)

# Bind the socket to the address and port
sock.bind((address, port))

# Create an empty list to store the received fragments
fragments = []

# Receive all of the fragments
while True:
    # Receive a fragment from the network
    fragment, addr = sock.recvfrom(65535)
    
    # If the fragment is empty, we have received all of the fragments
    if not fragment:
        break
    
    # Add the fragment to the list of received fragments
    fragments.append(fragment)

# Close the socket
sock.close()

# Reassemble the fragments into the original message
datagram, message = ip_reassembly(fragments)

# Print the original message
print('Received message:', message)


