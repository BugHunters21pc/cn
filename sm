KEYS: 

note: add sk- in the starting for valid key.

21pc13 - ir03zcgGgr9UkFYiwGxvT3BlbkFJLag01jLVoe6Ou8rmNURP

21pc19 - OTaSzNANFaH4Zmuvq0ZnT3BlbkFJY4mcSLWyAPW3eL2ncMnP

21pc01 - MnNdC1SzSEAVCbkCjWszT3BlbkFJC2pLCtUuSSOFZ2FEHnk0

21pc23 - INRCrAyyf59hecbwEzZ4T3BlbkFJwxOHbwTHMxmSt38tCMl0

21pc09 - 1jApbfQ7iUzaC3GHHdDhT3BlbkFJUTdesQZ3HR4k1S1iRZtb

21pc18 - CPGhX4VVVKt2upUsQXasT3BlbkFJTYdxA1WyYxKyvQiSlW74

21PC17 - N3SGxCzzYXhklGVdYONzT3BlbkFJ8OkrvzwTGUIWqCESyGFy

21PC25-  seTTDNEvkkbhI3WmCauyT3BlbkFJycCBfk5MVkv4HOb2XYeI

21PC31 - 74evNFm4ggpif3IgA2pGT3BlbkFJzPhlTuYbxQWHQQFGxqhB
 
21PC29 - MxneXSIrPTOBvEKWOGx7T3BlbkFJ9rv0hg1pyQPw3UtVSuzL

21PC05 - NpkxX52f5PP9yrDr3vEXT3BlbkFJVl8yy28JgXNAtjtcFLC1

21PC11 - dFb0vJEFxogCg9V6pYNrT3BlbkFJm1r4ZNzv4QSCLt4xDGPp

21pc08 - CczCJ2AJ25eiIQyIhvdST3BlbkFJoG5JGbrwGWWcq1TcX2Fq

21pc07 - as7gS0iDPVAwNlEsX1QKT3BlbkFJZqpvxsdsBvXiFKTmwFx0

21PC33 - WiFt7TW5SiPGINOSKMSKT3BlbkFJx78bP0jXvVY7qQ1AEKOp

21PC03 - bjmFzzIlFQN5NF991KYTT3BlbkFJuDBP3rTgh58b0rIFW8Cq

21PC22 - 8MYhqw0oMftMpE3J2plHT3BlbkFJKdbc5xdIJ8qxrCM6yPHE

21PC16 - nuQfsp7Pdkgbz3zBiBK8T3BlbkFJ5I2YTgLGuvelHN1GLae4

21PC10 - tp0ABygyRFX9J8dSfMUTT3BlbkFJiKjnBJQuMuQNupGSQrFn

21PC28 - AGb10wZYfzxfISn32BY7T3BlbkFJ4VivBAgrCJOHdvE8b5en

21PC04 - lra8SADSevtbaNF3g2X0T3BlbkFJgSZ9ZyKw9GDO961p8Z6L

SMRITHI ticbNikh8ATmr5cn2Q3zT3BlbkFJHYTzkzWp5r8MTBBmUk4i


import openai

openai.api_key = "your api key"


response = openai.ChatCompletion.create(
    model="gpt-3.5-turbo",
    messages=[
            {"role": "system", "content": "You are a chatbot"},
            {"role": "user", "content": "implement BELLMAN FORD algorithm using python"},
        ]
)

result = ''
for choice in response.choices:
    result += choice.message.content

print(result)

#reciever Go back N arq

import socket

# Initialize socket
sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
server_address = ('localhost', 10000)
sock.bind(server_address)

# Expected sequence number
expected_seq_num = 0

# Window size
N = 3

while True:
    # Receive packet
    packet, address = sock.recvfrom(1024)
    packet_data = packet.decode().split(':')
    seq_num = int(packet_data[0])
    message = packet_data[1]
    
    print("OUTER")
    # Check sequence number
    if seq_num == expected_seq_num:
        print(message)

        # Send ACK
        ack = str(seq_num)
        sock.sendto(ack.encode(), address)

        # Move window
        expected_seq_num += 1
        print("exp_seq :", expected_seq_num)

        # Handle out-of-order packets
        while True:
            print("INNER")
            try:
                packet, address = sock.recvfrom(1024)
                packet_data = packet.decode().split(':')
                seq_num = int(packet_data[0])
                message = packet_data[1]

                if seq_num == expected_seq_num:
                    print(message)

                    # Send ACK
                    ack = str(seq_num)
                    sock.sendto(ack.encode(), address)

                    # Move window
                    expected_seq_num += 1
                else:
                    break
            except socket.timeout:
                break
    else:
        # Discard packet
        pass

#sender Go Back N arq

import socket

# Initialize socket
sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
server_address = ('localhost', 10000)

# Data to be sent
data = ['packet1', 'packet2', 'packet3', 'packet4', 'packet5']

# Window size
N = 3

# Sequence number
seq_num = 0

# Send packets
while seq_num < len(data):
    print(f"seq:{seq_num}")
    # Send N packets
    for i in range(seq_num, min(seq_num + N, len(data))):
        message = str(seq_num) + ':' + data[i]
        print(message)
        sock.sendto(message.encode(), server_address)
    # Wait for ACKs
    try:
        sock.settimeout(1)
        while True:
            ack, address = sock.recvfrom(1024)
            ack_seq_num = int(ack.decode())
            print(f"ack: {ack_seq_num}")
            if ack_seq_num >= seq_num:
                seq_num = ack_seq_num + 1
                
    except socket.timeout:
        pass
# selective repeat 

//selective repeat
import socket

def client_program():
	n = 4
    	win_start = 0
	win_end = win_start + n - 1
	host = socket.gethostname()  # as both code is running on same pc
	port = 12344  # socket server port number
	sender = []
	flag = 0 #send whole sender list else 1 means send only win_start frame
	client_socket = socket.socket()  # instantiate
	client_socket.connect((host, port))  # connect to the server
	print 'Window Size is ', n
	print '******** Enter "bye" to close connection ***************'
        message = raw_input("Hit any key to start sending frames -> ")  # take input
        while message.lower().strip() != 'bye':
		print "Sending frames..."
		if (flag == 0):
			for i in range(n):
				sender.append(win_start + i)
			for i in sender :
				print "Frame -> ", i
		else:
			print "Frame -> ", win_start
		msg = str(win_start)
        	client_socket.send(msg.encode())  # send message
        	data = client_socket.recv(1024).decode()  # receive NAK
		msg = str(data)
		ack = int(msg)
		if ack not in sender:
			win_start = ack
			win_end = win_start + n - 1
			flag = 0         		#send new frame
			for i in range(n):
				sender.pop()
		else:
			win_start = int(msg)
			flag = 1			#send old frame
			
		print "************************************"
        	print 'Received ACK server: ' + data  # show in terminal
		
        	message = raw_input("Hit any key to start sending frames -> ")  # again take input

    	client_socket.close()  # close the connection


if __name__ == '__main__':
    client_program()


######################### OUTPUT : Client Side #################################

Window Size is  4
******** Enter "bye" to close connection ***************
Hit any key to start sending frames -> 
Sending frames...
Frame ->  0
Frame ->  1
Frame ->  2
Frame ->  3
************************************
Received ACK server: 4
Hit any key to start sending frames -> 
Sending frames...
Frame ->  4
Frame ->  5
Frame ->  6
Frame ->  7
************************************
Received ACK server: 4
Hit any key to start sending frames -> 
Sending frames...
Frame ->  4
************************************
Received ACK server: 7
Hit any key to start sending frames -> 
Sending frames...
Frame ->  7
************************************
Received ACK server: 8
Hit any key to start sending frames -> 
Sending frames...
Frame ->  8
Frame ->  9
Frame ->  10
Frame ->  11
************************************
Received ACK server: 12
Hit any key to start sending frames -> bye


import socket
import random
def server_program():
    # get the hostname
    host = socket.gethostname()
    port = 12344  # initiate port no above 1024
    exp = 0
    n = 4
    new = 1
    win_start = 0
    win_end   = win_start + n - 1
    receiver = []
    server_socket = socket.socket()  # get instance
    # look closely. The bind() function takes tuple as argument
    server_socket.bind((host, port))  # bind host address and port together

    # configure how many client the server can listen simultaneously
    server_socket.listen(2)
    conn, address = server_socket.accept()  # accept new connection
    print "Connection from: ", str(address)
    while True:
        # receive data stream. it won't accept data packet greater than 1024 bytes
        data = conn.recv(1024).decode()
        if not data:
            # if data is not received break
            break
	rec = int(data)
	lim = rec + n - 1
	count = 0
	flag = 0
	ack = rec
	
	
	randy = random.randint(1, 4)
	if new == 1 : 			#you received a new frame of a new window
		while(count != randy):
			temp = random.randint(rec, lim)
			
			if temp not in receiver:
				print "Received Frame -> ", temp
				count+=1
				flag = 1       #Atleast one new frame added in receiver buffer
				receiver.append(temp)
	else :
		print "Received Frame -> ", rec       #you received a new frame of an old window  
		receiver.append(rec)
		flag = 1
        if(flag == 1):
		for i in range(rec,lim+1):
			if i not in receiver:
				ack = i
				break
			ack = i+1
	
	print "Sending ACK    -> ", ack #next expected frame
        print '***************************************************'
	data = str(ack)
        conn.send(data.encode())  # send data to the client

	if ack > win_end :
		win_start = ack
		win_end   = win_start + n - 1
		new = 1			# now receive a new frame of a new window
	else :
		new = 0 		# now received a new frame of an old window

    conn.close()  # close the connection


if __name__ == '__main__':
    server_program()

############################# OUTPUT : Server Side ##########################
Connection from:  ('127.0.0.1', 40912)
Received Frame ->  0
Received Frame ->  3
Received Frame ->  2
Received Frame ->  1
Sending ACK    ->  4
***************************************************
Received Frame ->  6
Received Frame ->  5
Sending ACK    ->  4
***************************************************
Received Frame ->  4
Sending ACK    ->  7
***************************************************
Received Frame ->  7
Sending ACK    ->  8
***************************************************
Received Frame ->  9
Received Frame ->  11
Received Frame ->  8
Received Frame ->  10
Sending ACK    ->  12
***************************************************
sayali@sayali:~/Desktop/Saiy/MyDocs/CN $ '''
Footer
Â© 2023 GitH

#### bellmanford 


def bellman_ford(graph, start):
    # Initialize the distances dictionary with start vertex having distance 0 and all other vertices having infinity distance.
    distances = {vertex: float('infinity') for vertex in graph}
    distances[start] = 0
    
    # Iterate over all edges V-1 times, where V is the number of vertices in the graph.
    for _ in range(len(graph) - 1):
        # For each edge (u, v) with weight w in the graph, update the distance to v if the distance to u plus w is smaller than the current distance to v.
        for u in graph:
            for v, w in graph[u].items():
                if distances[u] + w < distances[v]:
                    distances[v] = distances[u] + w
    
    # Check for negative-weight cycles.
    for u in graph:
        for v, w in graph[u].items():
            if distances[u] + w < distances[v]:
                raise ValueError("Negative weight cycle detected")
    
    return distances

graph = {
    'A': {'B': 3, 'C': 4, 'D': 2},
    'B': {'A': 3, 'C': 5, 'E': 9},
    'C': {'A': 4, 'B': 5, 'D': 1, 'E': 6},
    'D': {'A': 2, 'C': 1, 'F': 8},
    'E': {'B': 9, 'C': 6, 'F': 7},
    'F': {'D': 8, 'E': 7}
}

print(bellman_ford(graph, 'A'))


#Dijikstra

import heapq

def dijkstra(graph, start):
    distances = {vertex: float('infinity') for vertex in graph}  # Set all initial distances to infinity
    #print(distances)
    distances[start] = 0  # Set the starting vertex's distance to 0
    pq = [(0, start)]  # Add the starting vertex to the heap with priority 0
   
    visited = set()  # Keep track of visited vertices
    
    while pq:
        current_distance, current_vertex = heapq.heappop(pq)  # Get the vertex with the smallest distance
        
        print (current_distance, current_vertex)
        #print(pq)
        if current_vertex in visited:
            continue  # Skip if we've already visited this vertex
        
        visited.add(current_vertex)  # Mark the vertex as visited
        
        for neighbor, weight in graph[current_vertex].items():  # Check each neighboring vertex
            distance = current_distance + weight  # Calculate the distance to the neighboring vertex
            
            if distance < distances[neighbor]:  # If the new distance is less than the previously calculated distance
                distances[neighbor] = distance  # Update the distance
                heapq.heappush(pq, (distance, neighbor))  # Add the neighboring vertex to the heap with the updated distance
        #print(distances)       
    return distances


graph = {
    'A': {'B': 3, 'C': 4, 'D': 2},
    'B': {'A': 3, 'C': 5, 'E': 9},
    'C': {'A': 4, 'B': 5, 'D': 1, 'E': 6},
    'D': {'A': 2, 'C': 1, 'F': 8},
    'E': {'B': 9, 'C': 6, 'F': 7},
    'F': {'D': 8, 'E': 7}
}

start_vertex = 'A'
distances = dijkstra(graph, start_vertex)
print(distances)

#Dijkstra if src and dst

import heapq


def dijkstra(graph, start, end):
    distances = {vertex: float('infinity') for vertex in graph}  # Set all initial distances to infinity
    distances[start] = 0  # Set the starting vertex's distance to 0
    pq = [(0, start)]  # Add the starting vertex to the heap with priority 0
    visited = set()  # Keep track of visited vertices
    previous_vertices = {vertex: None for vertex in graph}  # Keep track of previous vertices
    
    while pq:
        current_distance, current_vertex = heapq.heappop(pq)  # Get the vertex with the smallest distance
        
        if current_vertex == end:
            break  # If we've reached the end vertex, exit the loop
        
        if current_vertex in visited:
            continue  # Skip if we've already visited this vertex
        
        visited.add(current_vertex)  # Mark the vertex as visited
        
        for neighbor, weight in graph[current_vertex].items():  # Check each neighboring vertex
            distance = current_distance + weight  # Calculate the distance to the neighboring vertex
            
            if distance < distances[neighbor]:  # If the new distance is less than the previously calculated distance
                distances[neighbor] = distance  # Update the distance
                previous_vertices[neighbor] = current_vertex  # Update the previous vertex
                heapq.heappush(pq, (distance, neighbor))  # Add the neighboring vertex to the heap with the updated distance
                
    path = [end]  # Start with the end vertex
    current_vertex = end
    
    while current_vertex != start:
        previous_vertex = previous_vertices[current_vertex]
        path.append(previous_vertex)
        current_vertex = previous_vertex
        
    path.reverse()  # Reverse the path to get the correct order
    
    return distances[end], path


graph = {
    'R1': {'R2': 10, 'R3': 5, 'NetworkA': 0, 'NetworkB': 0},
    'R2': {'R1': 10, 'R3': 6, 'NetworkC': 0},
    'R3': {'R1': 5, 'R2': 6, 'NetworkD': 0},
    'NetworkA': {'R1': 0},
    'NetworkB': {'R1': 0},
    'NetworkC': {'R2': 0},
    'NetworkD': {'R3': 0}
}


start_vertex = 'NetworkA'
end = 'NetworkD'
distance, path = dijkstra(graph, start_vertex, end)
print(f"The shortest distance from {start_vertex} to {end} is {distance}.")
print(f"The path is {path}.")


#Bellman ford

def bellman_ford(graph, start):
    # Initialize the distances dictionary with start vertex having distance 0 and all other vertices having infinity distance.
    distances = {vertex: float('infinity') for vertex in graph}
    distances[start] = 0
    
    # Iterate over all edges V-1 times, where V is the number of vertices in the graph.
    for _ in range(len(graph) - 1):
        # For each edge (u, v) with weight w in the graph, update the distance to v if the distance to u plus w is smaller than the current distance to v.
        for u in graph:
            for v, w in graph[u].items():
                if distances[u] + w < distances[v]:
                    distances[v] = distances[u] + w
    
    # Check for negative-weight cycles.
    for u in graph:
        for v, w in graph[u].items():
            if distances[u] + w < distances[v]:
                raise ValueError("Negative weight cycle detected")
    
    return distances

graph = {
    'A': {'B': 3, 'C': 4, 'D': 2},
    'B': {'A': 3, 'C': 5, 'E': 9},
    'C': {'A': 4, 'B': 5, 'D': 1, 'E': 6},
    'D': {'A': 2, 'C': 1, 'F': 8},
    'E': {'B': 9, 'C': 6, 'F': 7},
    'F': {'D': 8, 'E': 7}
}

print(bellman_ford(graph, 'A'))

#ip fragmentation

import sys

def ip_fragmentation(data, mtu):
    # Maximum IP packet size is 65535 bytes
    max_size = 65535
    
    # Calculate the number of fragments needed
    num_fragments = (len(data) // (mtu - 20)) + 1 if len(data) % (mtu - 20) != 0 else (len(data) // (mtu - 20))
    
    # Create an empty list to store the fragments
    fragments = []
    
    # Generate a unique identifier for the IP packet
    ip_id = 1234
    
    # Create the IP header
    ip_header = b'\x45\x00\x00\x00'  # Version, header length, type of service
    ip_header += (max_size).to_bytes(2, byteorder='big')  # Total length
    ip_header += (ip_id).to_bytes(2, byteorder='big')  # Identification
    ip_header += b'\x00\x00\x00\x00'  # Flags, fragment offset
    ip_header += b'\x40\x00\x00\x00'  # Time-to-live, protocol
    ip_header += b'\x00\x00'  # Header checksum
    ip_header += b'\x00\x00\x00\x00'  # Source IP address
    ip_header += b'\x00\x00\x00\x00'  # Destination IP address
    
    # Loop through the data and fragment it
    for i in range(num_fragments):
        # Calculate the offset for this fragment
        offset = (i * (mtu - 20)) // 8
        
        # Create the IP header for this fragment
        fragment_header = ip_header[:6]  # Version, header length, type of service
        fragment_header += (mtu).to_bytes(2, byteorder='big')  # Total length
        fragment_header += (ip_id).to_bytes(2, byteorder='big')  # Identification
        fragment_header += (((i != num_fragments - 1) * 2**13) + offset).to_bytes(2, byteorder='big')  # Flags, fragment offset
        fragment_header += ip_header[10:]  # Time-to-live, protocol, header checksum, source and destination IP addresses
        
        # Create the fragment by appending the header and the data
        fragment = fragment_header + data[i * (mtu - 20):(i + 1) * (mtu - 20)]
        
        # Add the fragment to the list of fragments
        fragments.append(fragment)
    
    # Return the list of fragments
    return fragments

def ip_reassembly(fragments):
    # Create a dictionary to store the fragments
    fragment_dict = {}
    
    # Loop through the fragments and store them in the dictionary
    for fragment in fragments:
        # Extract the identification and flags/offset fields from the IP header
        ip_id = int.from_bytes(fragment[4:6], byteorder='big')
        flags_offset = int.from_bytes(fragment[6:8], byteorder='big')
        
        # Extract the flags and fragment offset from the flags/offset field
        flags = flags_offset & 0xE000
        offset = flags_offset & 0x1FFF
        
        # If this is the first fragment, create a new entry in the dictionary
        if flags == 0:
            fragment_dict[ip_id] = [None] * ((offset + len(fragment) - 20) // 8 + 1)
        
        # Add the fragment to the list in the dictionary at the appropriate offset
        fragment_dict[ip_id][offset // 8] = fragment[20:]
    
    # Combine the fragments into a single bytearray
    datagram = bytearray()
    for key, value in fragment_dict.items():
        for fragment in value:
            if fragment is not None:
                datagram += fragment
    
    # Extract the original message from the datagram
    message = datagram[20:]
    
    # Return the datagram and the message
    return datagram, message


# Fragment the message
message = b'This is a test message to be fragmented into multiple IP packets.'
mtu = 50
fragments = ip_fragmentation(message, mtu)

print(fragments)

# Reassemble the fragments
datagram, message = ip_reassembly(fragments);          

# Print the results
print('Datagram:', datagram.hex())
print('Message:', message.decode())

#sender part for ip

import socket
import sys
sys.path.append('/path/to/the/directory')

# Define the address and port to send the message to
address = '127.0.0.1'
port = 12345

# Define the message to send
message = b'This is a test message to be fragmented into multiple IP packets.'

# Define the maximum transmission unit (MTU) for the network
mtu = 50

# Fragment the message
fragments = ip_fragmentation(message, mtu)

# Create a UDP socket
sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)

# Send each fragment over the network
for fragment in fragments:
    sock.sendto(fragment, (address, port))

# Close the socket
sock.close()

#reciever part for ip

import socket
import sys
sys.path.append('/path/to/the/directory')

# Define the address and port to receive the message on
address = '127.0.0.1'
port = 12345

# Create a UDP socket
sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)

# Bind the socket to the address and port
sock.bind((address, port))

# Create an empty list to store the received fragments
fragments = []

# Receive all of the fragments
while True:
    # Receive a fragment from the network
    fragment, addr = sock.recvfrom(65535)
    
    # If the fragment is empty, we have received all of the fragments
    if not fragment:
        break
    
    # Add the fragment to the list of received fragments
    fragments.append(fragment)

# Close the socket
sock.close()

# Reassemble the fragments into the original message
datagram, message = ip_reassembly(fragments)

# Print the original message
print('Received message:', message)

@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ go back n arq receiver @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@CHAT ROOM THINGY
import time, socket, sys
import random

print("\nWelcome to Chat Room\n")
print("Initialising....\n")
time.sleep(1)

s = socket.socket()
shost = socket.gethostname()
ip = socket.gethostbyname(shost)
print(shost, "(", ip, ")\n")
host = input(str("Enter server address: "))
name = input(str("\nEnter your name: "))
port = 1234
print("\nTrying to connect to ", host, "(", port, ")\n")
time.sleep(1)
s.connect((host, port))
print("Connected...\n")

s.send(name.encode())
s_name = s.recv(1024)
s_name = s_name.decode()
print(s_name, "has joined the chat room\nEnter [e] to exit chat room\n")

while True:

    m=s.recv(1024)
    m=m.decode()
    k=s.recv(1024)
    k=k.decode()
    k=int(k)
    i=0
    a=""
    b=""
    f=random.randint(0,1)
    message=""
    while i!=k:
       
       
       f=random.randint(0,1)
       if(f==0):
          b="ACK Lost"
          message = s.recv(1024)
          message = message.decode()
          s.send(b.encode())
         
       elif(f==1):
          b="ACK "+str(i)
          message = s.recv(1024)
          message = message.decode()
          
          s.send(b.encode())
          a=a+message
          i=i+1
          
       
    
    print("The message received is :", m)
    
    @@@@@@@@@@@@@@@@SENDER@@@@@@@@@@@@@@@@
    
    # Sender.py
import time, socket, sys

def decimalToBinary(n):  
    return n.replace("0b", "")

def binarycode(s):
    a_byte_array = bytearray(s, "utf8")

    byte_list = []

    for byte in a_byte_array:
        binary_representation = bin(byte)
        byte_list.append(decimalToBinary(binary_representation))

    #print(byte_list)
    a=""
    for i in byte_list:
        a=a+i
    return a

print("\nWelcome to Chat Room\n")
print("Initialising....\n")
time.sleep(1)

s = socket.socket()
host = socket.gethostname()
ip = socket.gethostbyname(host)
port = 1234
s.bind((host, port))
print(host, "(", ip, ")\n")
name = input(str("Enter your name: "))
           
s.listen(1)
print("\nWaiting for incoming connections...\n")
conn, addr = s.accept()
print("Received connection from ", addr[0], "(", addr[1], ")\n")

s_name = conn.recv(1024)
s_name = s_name.decode()
print(s_name, "has connected to the chat room\nEnter [e] to exit chat room\n")
conn.send(name.encode())

while True:
    message = input(str("Me : "))
    conn.send(message.encode())
    if message == "[e]":
        message = "Left chat room!"
        conn.send(message.encode())
        print("\n")
        break
    message=binarycode(message)
    f=str(len(message))
    conn.send(f.encode())
   
    i=0
    j=0
    j=int(input("Enter the window size -> "))
    
   
    b=""
   
    j=j-1
    f=int(f)
    k=j
    while i!=f:
        while(i!=(f-j)):
            conn.send(message[i].encode())
            b=conn.recv(1024)
            b=b.decode()
            print(b)
            if(b!="ACK Lost"):
                time.sleep(1)
                print("Acknowledgement Received! The sliding window is in the range "+(str(i+1))+" to "+str(k+1)+" Now sending the next packet")
                i=i+1
                k=k+1
                time.sleep(1)
            else:
                time.sleep(1)
                print("Acknowledgement of the data bit is LOST! The sliding window remains in the range "+(str(i+1))+" to "+str(k+1)+" Now Resending the same packet")
                time.sleep(1)
        while(i!=f):
            
            conn.send(message[i].encode())
            b=conn.recv(1024)
            b=b.decode()
            print(b)
            if(b!="ACK Lost"):
                time.sleep(1)
                print("Acknowledgement Received! The sliding window is in the range "+(str(i+1))+" to "+str(k)+" Now sending the next packet")
                i=i+1
                time.sleep(1)
            else:
                time.sleep(1)
                print("Acknowledgement of the data bit is LOST! The sliding window remains in the range "+(str(i+1))+" to "+str(k)+" Now Resending the same packet")
                time.sleep(1)
            
            
@@@@@@@@@@@@@@@@@@@@@@@@ vishnu code @@@@@@@@@@@@@@@@@@@@@@@@



import heapq

def dijkstra(graph, start, end):
    """
    Compute the shortest path between start and end in the given graph using Dijkstra's algorithm.
    Returns the shortest path and its cost.
    """
    queue = [(0, start, [])]
    visited = set()
    while queue:
        (cost, node, path) = heapq.heappop(queue)
        if node not in visited:
            visited.add(node)
            path = path + [node]
            if node == end:
                return path, cost
            for neighbor, neighbor_cost in graph[node].items():
                if neighbor not in visited:
                    heapq.heappush(queue, (cost + neighbor_cost, neighbor, path))
    return None, None

# Define the network topology and link costs
network_topology = {
    'A': {'B': 5, 'C': 3},
    'B': {'A': 5, 'C': 2, 'D': 4},
    'C': {'A': 3, 'B': 2, 'D': 7},
    'D': {'B': 4, 'C': 7},
}

# Define the path for each IP fragment
fragment_paths = []
fragment_paths.append(['A', 'B', 'D'])  # path for fragment 1
fragment_paths.append(['A', 'C', 'D'])  # path for fragment 2
fragment_paths.append(['B', 'C', 'D'])  # path for fragment 3

# Compute the shortest path and its cost for each IP fragment
for i, path in enumerate(fragment_paths):
    start = path[0]
    end = path[-1]
    shortest_path, cost = dijkstra(network_topology, start, end)
    print("Shortest path for fragment {}: {}".format(i+1, shortest_path))
    print("Cost of shortest path for fragment {}: {}".format(i+1, cost))
    
    
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$ KAAAVYA CODES $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$

SELECTIVE REPEAT SENDER 


#Name    : Sayali Deo
#Roll No : 7926
#Class   : TE Computers
#Batch   : A
# Selective Repeat ARQ - Server Side Code

import socket
import random
def server_program():
    # get the hostname
    host = socket.gethostname()
    port = 12344  # initiate port no above 1024
    exp = 0
    n = 4
    new = 1
    win_start = 0
    win_end   = win_start + n - 1
    receiver = []
    server_socket = socket.socket()  # get instance
    # look closely. The bind() function takes tuple as argument
    server_socket.bind((host, port))  # bind host address and port together

    # configure how many client the server can listen simultaneously
    server_socket.listen(2)
    conn, address = server_socket.accept()  # accept new connection
    print "Connection from: ", str(address)
    while True:
        # receive data stream. it won't accept data packet greater than 1024 bytes
        data = conn.recv(1024).decode()
        if not data:
            # if data is not received break
            break
	rec = int(data)
	lim = rec + n - 1
	count = 0
	flag = 0
	ack = rec
	
	
	randy = random.randint(1, 4)
	if new == 1 : 			#you received a new frame of a new window
		while(count != randy):
			temp = random.randint(rec, lim)
			
			if temp not in receiver:
				print "Received Frame -> ", temp
				count+=1
				flag = 1       #Atleast one new frame added in receiver buffer
				receiver.append(temp)
	else :
		print "Received Frame -> ", rec       #you received a new frame of an old window  
		receiver.append(rec)
		flag = 1
        if(flag == 1):
		for i in range(rec,lim+1):
			if i not in receiver:
				ack = i
				break
			ack = i+1
	
	print "Sending ACK    -> ", ack #next expected frame
        print '***************************************************'
	data = str(ack)
        conn.send(data.encode())  # send data to the client

	if ack > win_end :
		win_start = ack
		win_end   = win_start + n - 1
		new = 1			# now receive a new frame of a new window
	else :
		new = 0 		# now received a new frame of an old window

    conn.close()  # close the connection


if __name__ == '__main__':
    server_program()

############################# OUTPUT : Server Side ##########################
'''sayali@sayali:~/Desktop/Saiy/MyDocs/CN $ python serselect.py
Connection from:  ('127.0.0.1', 40912)
Received Frame ->  0
Received Frame ->  3
Received Frame ->  2
Received Frame ->  1
Sending ACK    ->  4
***************************************************
Received Frame ->  6
Received Frame ->  5
Sending ACK    ->  4
***************************************************
Received Frame ->  4
Sending ACK    ->  7
***************************************************
Received Frame ->  7
Sending ACK    ->  8
***************************************************
Received Frame ->  9
Received Frame ->  11
Received Frame ->  8
Received Frame ->  10
Sending ACK    ->  12
***************************************************
sayali@sayali:~/Desktop/Saiy/MyDocs/CN $ '''



RECEIVER 

import socket

def client_program():
	n = 4
    	win_start = 0
	win_end = win_start + n - 1
	host = socket.gethostname()  # as both code is running on same pc
	port = 12344  # socket server port number
	sender = []
	flag = 0 #send whole sender list else 1 means send only win_start frame
	client_socket = socket.socket()  # instantiate
	client_socket.connect((host, port))  # connect to the server
	print 'Window Size is ', n
	print '******** Enter "bye" to close connection ***************'
        message = raw_input("Hit any key to start sending frames -> ")  # take input
        while message.lower().strip() != 'bye':
		print "Sending frames..."
		if (flag == 0):
			for i in range(n):
				sender.append(win_start + i)
			for i in sender :
				print "Frame -> ", i
		else:
			print "Frame -> ", win_start
		msg = str(win_start)
        	client_socket.send(msg.encode())  # send message
        	data = client_socket.recv(1024).decode()  # receive NAK
		msg = str(data)
		ack = int(msg)
		if ack not in sender:
			win_start = ack
			win_end = win_start + n - 1
			flag = 0         		#send new frame
			for i in range(n):
				sender.pop()
		else:
			win_start = int(msg)
			flag = 1			#send old frame
			
		print "************************************"
        	print 'Received ACK server: ' + data  # show in terminal
		
        	message = raw_input("Hit any key to start sending frames -> ")  # again take input

    	client_socket.close()  # close the connection


if __name__ == '__main__':
    client_program()


######################### OUTPUT : Client Side #################################
Window Size is  4
******** Enter "bye" to close connection ***************
Hit any key to start sending frames -> 
Sending frames...
Frame ->  0
Frame ->  1
Frame ->  2
Frame ->  3
************************************
Received ACK server: 4
Hit any key to start sending frames -> 
Sending frames...
Frame ->  4
Frame ->  5
Frame ->  6
Frame ->  7
************************************
Received ACK server: 4
Hit any key to start sending frames -> 
Sending frames...
Frame ->  4
************************************
Received ACK server: 7
Hit any key to start sending frames -> 
Sending frames...
Frame ->  7
************************************
Received ACK server: 8
Hit any key to start sending frames -> 
Sending frames...
Frame ->  8
Frame ->  9
Frame ->  10
Frame ->  11
************************************
Received ACK server: 12
Hit any key to start sending frames -> bye

GO BACK RECEIVER 

import time, socket, sys
import random

print("\nWelcome to Chat Room\n")
print("Initialising....\n")
time.sleep(1)

s = socket.socket()
shost = socket.gethostname()
ip = socket.gethostbyname(shost)
print(shost, "(", ip, ")\n")
host = input(str("Enter server address: "))
name = input(str("\nEnter your name: "))
port = 1234
print("\nTrying to connect to ", host, "(", port, ")\n")
time.sleep(1)
s.connect((host, port))
print("Connected...\n")

s.send(name.encode())
s_name = s.recv(1024)
s_name = s_name.decode()
print(s_name, "has joined the chat room\nEnter [e] to exit chat room\n")

while True:

    m=s.recv(1024)
    m=m.decode()
    k=s.recv(1024)
    k=k.decode()
    k=int(k)
    i=0
    a=""
    b=""
    f=random.randint(0,1)
    message=""
    while i!=k:
       
       
       f=random.randint(0,1)
       if(f==0):
          b="ACK Lost"
          message = s.recv(1024)
          message = message.decode()
          s.send(b.encode())
         
       elif(f==1):
          b="ACK "+str(i)
          message = s.recv(1024)
          message = message.decode()
          
          s.send(b.encode())
          a=a+message
          i=i+1
          
       
    
    print("The message received is :", m)
    
    
    GO BACK SENDER
    
    # Sender.py
import time, socket, sys

def decimalToBinary(n):  
    return n.replace("0b", "")

def binarycode(s):
    a_byte_array = bytearray(s, "utf8")

    byte_list = []

    for byte in a_byte_array:
        binary_representation = bin(byte)
        byte_list.append(decimalToBinary(binary_representation))

    #print(byte_list)
    a=""
    for i in byte_list:
        a=a+i
    return a

print("\nWelcome to Chat Room\n")
print("Initialising....\n")
time.sleep(1)

s = socket.socket()
host = socket.gethostname()
ip = socket.gethostbyname(host)
port = 1234
s.bind((host, port))
print(host, "(", ip, ")\n")
name = input(str("Enter your name: "))
           
s.listen(1)
print("\nWaiting for incoming connections...\n")
conn, addr = s.accept()
print("Received connection from ", addr[0], "(", addr[1], ")\n")

s_name = conn.recv(1024)
s_name = s_name.decode()
print(s_name, "has connected to the chat room\nEnter [e] to exit chat room\n")
conn.send(name.encode())

while True:
    message = input(str("Me : "))
    conn.send(message.encode())
    if message == "[e]":
        message = "Left chat room!"
        conn.send(message.encode())
        print("\n")
        break
    message=binarycode(message)
    f=str(len(message))
    conn.send(f.encode())
   
    i=0
    j=0
    j=int(input("Enter the window size -> "))
    
   
    b=""
   
    j=j-1
    f=int(f)
    k=j
    while i!=f:
        while(i!=(f-j)):
            conn.send(message[i].encode())
            b=conn.recv(1024)
            b=b.decode()
            print(b)
            if(b!="ACK Lost"):
                time.sleep(1)
                print("Acknowledgement Received! The sliding window is in the range "+(str(i+1))+" to "+str(k+1)+" Now sending the next packet")
                i=i+1
                k=k+1
                time.sleep(1)
            else:
                time.sleep(1)
                print("Acknowledgement of the data bit is LOST! The sliding window remains in the range "+(str(i+1))+" to "+str(k+1)+" Now Resending the same packet")
                time.sleep(1)
        while(i!=f):
            
            conn.send(message[i].encode())
            b=conn.recv(1024)
            b=b.decode()
            print(b)
            if(b!="ACK Lost"):
                time.sleep(1)
                print("Acknowledgement Received! The sliding window is in the range "+(str(i+1))+" to "+str(k)+" Now sending the next packet")
                i=i+1
                time.sleep(1)
            else:
                time.sleep(1)
                print("Acknowledgement of the data bit is LOST! The sliding window remains in the range "+(str(i+1))+" to "+str(k)+" Now Resending the same packet")
                time.sleep(1)
            
	    
	 DIJIKSTRA 
	 
	 
	 def dijkstra(graph, start, end):
    # Initialize distances to all nodes as infinity
    distances = {node: float('inf') for node in graph}
    distances[start] = 0
    
    # Initialize the visited set and the predecessor dictionary
    visited = set()
    predecessors = {}
    
    while len(visited) < len(graph):
        # Find the unvisited node with the smallest distance
        current_node = min((node for node in graph if node not in visited), key=lambda node: distances[node])
        
        # If we've reached the destination node, construct the path and return it
        if current_node == end:
            path = []
            while current_node in predecessors:
                path.append(current_node)
                current_node = predecessors[current_node]
            path.append(start)
            path.reverse()
            return path, distances[end]
        
        # If we haven't reached the destination node yet, update the distances to its neighbors
        for neighbor, weight in graph[current_node].items():
            distance = distances[current_node] + weight
            if distance < distances[neighbor]:
                distances[neighbor] = distance
                predecessors[neighbor] = current_node
        
        # Mark the current node as visited
        visited.add(current_node)
    
    # If we've exhausted all reachable nodes without reaching the destination, there's no path
    return None, None


graph = {
    1: {2: 5, 4: 6},
    2: {3: 8, 5: 9, 6: 8},
    3: {5: 6, 8: 15},
    4: {6: 4, 7: 9},
    5: {9: 13},
    6: {7: 6, 8: 14},
    7: {9: 11},
    8: {9: 9, 10: 9},
    9: {10: 6, 11: 5, 12: 12},
    10: {},
    11: {},
    12: {}
}
print(dijkstra(graph, 1,12))

BELLMAN FORD 


def bellman_ford(graph, start, end):
    # Step 1: Initialize distances and predecessors
    distances = {node: float('inf') for node in graph}
    predecessors = {node: None for node in graph}
    distances[start] = 0

    # Step 2: Relax edges repeatedly
    for _ in range(len(graph) - 1):
        for node in graph:
            for neighbor, weight in graph[node].items():
                if distances[node] + weight < distances[neighbor]:
                    distances[neighbor] = distances[node] + weight
                    predecessors[neighbor] = node

    # Step 3: Check for negative-weight cycles
    for node in graph:
        for neighbor, weight in graph[node].items():
            if distances[node] + weight < distances[neighbor]:
                raise ValueError("Graph contains a negative-weight cycle")

    # Step 4: Build the shortest path
    path = []
    node = end
    while node is not None:
        path.append(node)
        node = predecessors[node]
    path.reverse()

    # Step 5: Return the shortest path and its weight
    return path, distances[end]


graph = {
    1: {2: 5, 4: 6},
    2: {3: 8, 5: 9, 6: 8},
    3: {5: 6, 8: 15},
    4: {6: 4, 7: 9},
    5: {9: 13},
    6: {7: 6, 8: 14},
    7: {9: 11},
    8: {9: 9, 10: 9},
    9: {10: 6, 11: 5, 12: 12},
    10: {},
    11: {},
    12: {}
}
print(bellman_ford(graph, 1,12))
